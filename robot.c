#pragma config(Sensor, in1,    uppersensor,    sensorAnalog)
#pragma config(Sensor, in2,    lowersensor,    sensorAnalog)
#pragma config(Sensor, in3,    shortsensor,    sensorAnalog)
#pragma config(Sensor, in4,    color_FrontRight, sensorAnalog)
#pragma config(Sensor, in5,    color_FrontLeft, sensorAnalog)
#pragma config(Sensor, in6,    color_BackRight, sensorAnalog)
#pragma config(Sensor, in7,    color_BackLeft, sensorAnalog)
#pragma config(Sensor, in8,    rearsensor,     sensorAnalog)
#pragma config(Sensor, dgtl5,  masterswitch,   sensorDigitalIn)
#pragma config(Sensor, dgtl6,  westpin,        sensorDigitalIn)
#pragma config(Sensor, dgtl7,  southpin,       sensorDigitalIn)
#pragma config(Sensor, dgtl8,  eastpin,        sensorDigitalIn)
#pragma config(Sensor, dgtl9,  northpin,       sensorDigitalIn)
#pragma config(Sensor, dgtl11, bumperBL,       sensorDigitalIn)
#pragma config(Sensor, dgtl12, bumperBR,       sensorDigitalIn)
#pragma config(Motor,  port2,           rightmotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftmotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           grabber,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//start of variables declaration
int lowervalue, uppervalue, shortvalue;
int new_FR_value, new_FL_value, new_BR_value, new_BL_value;  //JOHAN: replaces '__val2' variables
int cur_FR_value, cur_FL_value, cur_BR_value, cur_BL_value;  //JOHAN: replaces '__val1' variables
int FR_status, FL_status, BR_status, BL_status;  // JOHAN: new status variables
int boundarySensorsStatus;  // JOHAN: replaces 'is___Clear' variables
bool isDetectingBoundaries = true;  // JOHAN: new variale to control boundary detection task

bool isBall = false;
bool isOpponent = false;
bool isBallIn = false;
bool isCollectionArea = false;
bool isScanning = false;
string state = "waiting to start";

string orientation = "NONE";
int cur_dirn[2];  // JOHAN: replaces orientation_val
int motor_speed[2];  // JOHAN: new variable to store motor speeds
//end of variables declaration

//start of tunable parameters
int SERVO_START_POS = -30;
int SERVO_CATCH_POS = 115;
int DELAY_CATCH = 1;
int DELAY_RELEASE = 6;

int UPPER_SENSOR_THRESHOLD = 1000;
int LOWER_SENSOR_THRESHOLD_LOW = 550;
int LOWER_SENSOR_THRESHOLD_HIGH = 2500;
int SHORT_SENSOR_THRESHOLD_LOW = 1500;
int SHORT_SENSOR_THRESHOLD_HIGH = 2500;

int BOUNDARY_THRESHOLD = 25;
//end of tunable parameters

//start of functions
void read_compass() //read orientation
{
	cur_dirn[0] = SensorValue(westpin) - SensorValue(eastpin);
	cur_dirn[1] = SensorValue(southpin) - SensorValue(northpin);
}

/* JOHAN: move updated to suit update_motors() task */
/* See update_motors() task for details */
void move(int direction, int power){
	motor_speed[0] = motor_speed[1] = direction*power;
}

/* JOHAN: halt updated accordingly */
/* See update_motors() task for details */
void halt(){
	motor_speed[0] = motor_speed[1] = 0;
}

/* JOHAN: rotate updated accordingly and now only runs 2 lines */
/* See update_motors() task for details */
void rotate(int direction, int power){ //rotate robot
	// 1: CW, -1: CCW
	motor_speed[0] = direction*power;
	motor_speed[1] = -direction*power;
}

/* JOHAN: introduced new rotateTo() function */
/* Can now specify which direction to rotate to */
void rotateTo(int target_dirn_x, int target_dirn_y, int power){
	int z = cur_dirn[0]*target_dirn_y - cur_dirn[1]*target_dirn_x;

	if(z==0)return;  // in case have to turn 180 deg, decide the rotation decide the rotation direction manually

	z = z/abs(z);

	// z: 1 == CCW, -1 == CW
	state="start aligning";
	rotate(-z, power);
	while(cur_dirn[0] != target_dirn_x || cur_dirn[1] != target_dirn_y){}
	state="done aligning";
	halt();
}

/* JOHAN: align updated accordingly and only has 1 line now*/
/* See update_motors() task for details */
/* Am I changing this correctly? If i am, maybe consider removing this function? */
void align(){ //align to initial orientation
	rotateTo(0, -1, 30);
}

/* JOHAN: updated maneuver accordingly */
void maneuver(){ //LIST ALL SCENARIOS, INCLUDE BUMPERS ETC, include scenario when opponent detected
	int maskedStatus, rotationDirn;

	if(/*isballin == false && */boundarySensorsStatus){  //explorer mode
		maskedStatus = boundarySensorsStatus & 6;  //AND operation with 0110 for front sensors
		if(maskedStatus){
			state = "avoiding boundary";
			//move(-1, 30);
			//wait1Msec(1000);
			rotationDirn = (maskedStatus-3)/abs(maskedStatus-3);
			state="start rotating";
			clearTimer(T3);
			rotate(rotationDirn, 45);
			while(time1[T3] < 200 && isBall == false){}
			state="done rotating";
			halt();
			//   while(cur_dirn[0] != -rotationDirn || cur_dirn[1] != 0 && isBall == false){}
			//halt();
			//rotateTo(-rotationDirn, cur_dirn[0], 45);
		}
	}
	else if(/*isBallIn == true && */isCollectionArea == false && boundarySensorsStatus){
		maskedStatus = boundarySensorsStatus & 9;  //AND operation with 1001 for back sensors

		if(maskedStatus){
			state = "avoiding boundary";
			rotationDirn = (maskedStatus-3)/abs(maskedStatus-3);
			rotate(-rotationDirn, 45);
			wait1Msec(500);
			move(1, 80);
			//wait1Msec(1000);
			if(isBallIn) align();
		}
	}

	isDetectingBoundaries = true;

	//IVAN ADDED: if robot facing collection area, rotate back, to avoid detecting collection as ball, might not be necessary
	if(SensorValue(northpin) == 0 && isScanning == false && isBall == false){ //if robot facing north/northeast/northwest -> facing collection area
		align();
		move(-1,30);
		wait1Msec(3000); //move back 3s
	}
}

void scan() //rotate robot to scan
{
	isScanning = true;
	state = "scanning";
	clearTimer(T2);
	while(time1[T2] < 600 && isBall == false){ //rotate left
		rotate(-1,45);
		maneuver(); //if boundary detected, isScanning will be updated to false and the scan function will exit
	}

	clearTimer(T2);
	while(time1[T2] < 1200 && isBall == false){ //rotate right
		rotate(1,45);
		maneuver();
	}

	clearTimer(T2);
	while(time1[T2] < 600 && isBall == false){ //rotate left-> robot is back to facing south, fine tune timer
		rotate(-1,45);
		maneuver();
	}

	isScanning = false;
	halt();
}

void grab_ball() //ball catching mechanism
{
	for(int count = SERVO_START_POS; count <= SERVO_CATCH_POS; count++){ //swing down
		setServo(grabber, count);
		wait1Msec(DELAY_CATCH);
	}
	wait1Msec(2000);
}

void release_ball()
{
	for(int count = SERVO_CATCH_POS; count >= SERVO_START_POS; count--){ //swing up
		setServo(grabber, count);
		wait1Msec(DELAY_RELEASE);
	}
	wait1Msec(2000); //wait 2s for ball to roll down
}

//IVAN ADDED
void chiong_halfway()
{
	clearTimer(T1);
	while(time1[T1] < 2000){
		state = "moving forward";
		maneuver(); //only if boundary is detected, see function
		move(1, 100); //move forward
	}
}
void initialize() //initialize all values
{
	isBall = false;
	isOpponent = false;
	isBallIn = false;
	isCollectionArea = false;
  cur_FR_value = SensorValue(color_FrontRight);
  cur_FL_value = SensorValue(color_FrontLeft);
  cur_BR_value = SensorValue(color_BackRight);
  cur_BL_value = SensorValue(color_BackLeft);
  boundarySensorsStatus = 0;
  isDetectingBoundaries = true;
	setServo(grabber, SERVO_START_POS);
}
//end of functions

//start of side tasks
/* JOHAN: continuously update motor speeds */
/* is delay required here? */
task update_motors(){
  while(true){
  	wait1Msec(2);
    motor(leftmotor) = motor_speed[0];
    motor(rightmotor) = motor_speed[1];
  }
}

task detect_ball_opponent(){
	while(true){
		lowervalue = SensorValue(lowersensor);
		shortvalue = SensorValue(shortsensor);
		uppervalue = SensorValue(uppersensor);

		if(isBallIn == false){
			if((SensorValue(lowersensor) > LOWER_SENSOR_THRESHOLD_LOW && SensorValue(lowersensor) < LOWER_SENSOR_THRESHOLD_HIGH) || (SensorValue(shortsensor) < SHORT_SENSOR_THRESHOLD_HIGH && SensorValue(shortsensor) > SHORT_SENSOR_THRESHOLD_LOW)){
				if(SensorValue(uppersensor) > UPPER_SENSOR_THRESHOLD){  //upper sensor detects
					isBall = false; //WHAT IF IT DETECTS COLLECTION PLACE? -> MAKE SURE ROBOT ALWAYS FAR FROM COLLECTION/ FACING FORWARD?
					isOpponent = true;
				}
				else{
					isBall = true; //WHAT IF IT DETECTS COLLECTION PLACE? -> MAKE SURE ROBOT ALWAYS FAR FROM COLLECTION/ FACING FORWARD?
					isOpponent = false;
				}
			}
			else{
				isBall = false;
				isOpponent = false;
			}
		}
		else if(isBallIn == true && isCollectionArea == false){ //returning to collection
			if(SensorValue(bumperBR) == 0 && SensorValue(rearsensor) > 1000) //rear sensor doesn't detect anything
				isCollectionArea = true;
			//else if(SensorValue(rearsensor) < 2500 && SensorValue(rearsensor) > 500) //PLACE REAR SENSOR HIGHER THAN COLLECTION AREA
			//	isOpponent = true;
		}
	}
}
/* JOHAN: changed the boundary detection approach */
/* Now boundary sensors statuses are stored in 4 bits of an int variable */
/* Bit order (MSB->LSB): BL - FL - FR - BR */
task detect_boundaries(){
	while(true){
    wait1Msec(50);  //tune

    if(isDetectingBoundaries){
      new_FL_value = SensorValue(color_FrontLeft);
      new_FR_value = SensorValue(color_FrontRight);
      new_BL_value = SensorValue(color_BackLeft);
      new_BR_value = SensorValue(color_BackRight);

      FL_status = abs(new_FL_value-cur_FL_value)/BOUNDARY_THRESHOLD >= 1;
      FR_status = abs(new_FR_value-cur_FR_value)/BOUNDARY_THRESHOLD >= 1;
      BL_status = abs(new_BL_value-cur_BL_value)/BOUNDARY_THRESHOLD >= 1;
      BR_status = abs(new_BR_value-cur_BR_value)/BOUNDARY_THRESHOLD >= 1;

      boundarySensorsStatus = 8*BL_status + 4*FL_status + 2*FR_status + BR_status;

      cur_FL_value = new_FL_value;
      cur_FR_value = new_FR_value;
      cur_BL_value = new_BL_value;
      cur_BR_value = new_BR_value;

      //temporarily exit detection loop upon boundary detection
      isDetectingBoundaries = boundarySensorsStatus < 1;
    }

		//end of boundary detection

		read_compass();
	}
}
//end of side tasks


task main()
{
	startTask(detect_boundaries);
	startTask(detect_ball_opponent);
	startTask(update_motors);

	setServo(grabber, SERVO_START_POS);

	while(SensorValue(masterswitch) == 1) {}

	initialize();
	chiong_halfway();

	while(true){
		while(isBall == false){ //move and search until ball detected
			clearTimer(T1);
			while(time1[T1] < 2000 && isBall == false){ //move 2s or until ball is detected
				state = "moving forward";
				maneuver(); //only if boundary is detected, see function
				move(1, 45); //move forward
			}

			halt();

			if(isBall == false) //if after moving still doesn't detect the ball
				scan(); //rotate to scan
		}

		while(isBall == true && isBallIn == false) //approach ball
		{
			while(isBall == true && SensorValue(lowersensor) < 2100){ //approach until ball is within range (FINE TUNE)
				state = "approaching ball";
				move(1,30); //if suddenly ball gone, it will stop moving
				maneuver(); //do we need to care abt boundary when chasing ball? what if ball is at the corner?

				////IVAN ADDED: if ball too close
				//if(SensorValue(lowersensor) < 1700 && SensorValue(lowersensor) > 1400 && SensorValue(shortsensor) < 2500 && SensorValue(shortsensor) > 1500){
				//	move(-1, 30);
				//	wait1Msec(1000); //move back 1s
				//}
			}

			halt();

			if(isBall == true && SensorValue(lowersensor) > 1900 && SensorValue(lowersensor) < 2200){ //to check whether ball is within capturing range FINE TUNE if ball suddenly gone, skip this function
				state = "catching ball";
				grab_ball();
				isBallIn = true; //ONLY FOR TESTING
			}
			else
				scan();

			//in case ball gone while approaching, the code will loop from beginning (search ball)

			//if(/*SensorValue(shortsensor) > 1200*/ SensorValue(lowersensor) < 2500) //FINE TUNE, if after grab_ball is done, ball is in
			//	isBallIn = true;
			//else //rotate until find ball, ball should be nearby (logically)
			//	scan();
		}

		while(isBallIn == true && isCollectionArea == false){ //if ball is grabbed, return to collection, MAKE SURE CANNOT LOSE HOLD OF BALL
			align();

			while(isCollectionArea == false){ //need to add codes to task "detection" to check for collection area
				state = "returning home";
				maneuver();
				move(-1, 45); //move backwards
			}
			halt();

			release_ball(); //release ball to collection

			initialize();
			chiong_halfway();
			break;
			//after releasing, loop back to top
		}
	}
}
