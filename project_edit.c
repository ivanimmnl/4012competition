#pragma config(Sensor, in1,    uppersensor,    sensorAnalog)
#pragma config(Sensor, in2,    lowersensor,    sensorAnalog)
#pragma config(Sensor, in3,    shortsensor,    sensorAnalog)
#pragma config(Sensor, in4,    color_FrontRight, sensorAnalog)
#pragma config(Sensor, in5,    color_FrontLeft, sensorAnalog)
#pragma config(Sensor, in6,    color_BackRight, sensorAnalog)
#pragma config(Sensor, in7,    color_BackLeft, sensorAnalog)
#pragma config(Sensor, in8,    rearsensor,     sensorAnalog)
#pragma config(Sensor, dgtl1,  bumperFL,       sensorDigitalIn)
#pragma config(Sensor, dgtl2,  bumperFR,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  bumperBL,       sensorDigitalIn)
#pragma config(Sensor, dgtl4,  bumperBR,       sensorDigitalIn)
#pragma config(Sensor, dgtl6,  westpin,        sensorDigitalIn)
#pragma config(Sensor, dgtl7,  southpin,       sensorDigitalIn)
#pragma config(Sensor, dgtl8,  eastpin,        sensorDigitalIn)
#pragma config(Sensor, dgtl9,  northpin,       sensorDigitalIn)
#pragma config(Motor,  port2,           rightmotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftmotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           grabber,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//start of variables declaration
int FRval1, FLval1, BRval1, BLval1;
int FRval2, FLval2, BRval2, BLval2;
bool isFrontLeftclear, isFrontRightclear, isBackLeftclear, isBackRightclear = true;
int lowervalue;

bool isball = false;
bool isopponent = false;
bool isballin = false;
bool iscollectionarea = false;
bool isscanning = false;
string state = "waiting to start";

string orientation = "NONE";
int orientation_val = 0;
//end of variables declaration


//start of functions
void read_compass() //read orientation
{
	orientation_val = 8*SensorValue(westpin)+4*SensorValue(southpin)+2*SensorValue(eastpin)+SensorValue(northpin);
	switch(orientation_val)
	{
	case 14:
		orientation = "NORTH";
		break;
	case 13:
		orientation = "EAST";
		break;
	case 11:
		orientation = "SOUTH";
		break;
	case 7:
		orientation = "WEST";
		break;
	case 12:
		orientation = "NORTHEAST";
		break;
	case 9:
		orientation = "SOUTHEAST";
		break;
	case 3:
		orientation = "SOUTHWEST";
		break;
	case 6:
		orientation = "NORTHWEST";
		break;
	default:
		orientation = "NONE";
	}
}


void move(int direction, int power) //move robot
{
	motor(leftmotor) = direction*power;
	motor(rightmotor) = direction*power;
}

void halt() //stop robot
{
	motor(leftmotor) = 0;
	motor(rightmotor) = 0;
}

void rotate(int direction, int power) //rotate robot
{
	if(direction == 1) //CW
	{
		motor(leftmotor) = power;
		motor(rightmotor) = -power;
	}
	else if(direction == -1) //CCW
	{
		motor(rightmotor) = power;
		motor(leftmotor) = -power;
	}
}

void align() //align to initial orientation
{
	if(isballin == true) //returning to collection
	{
		if(SensorValue(eastpin) == 1)
		{
			while(orientation_val != 11) //south
			{
				rotate(1,30);
				wait1Msec(200);
			}
		}
		else if(SensorValue(westpin) == 1)
		{
			while(orientation_val != 11) //south
			{
				rotate(-1,30);
				wait1Msec(200);
			}
		}
		halt();
	}
	else //if explorer mode, stop rotating if ball detected
	{
		if(SensorValue(eastpin) == 1)
		{
			while(orientation_val != 11 && isball == false) //south
			{
				rotate(1,30);
				wait1Msec(200);
			}
		}
		else if(SensorValue(westpin) == 1)
		{
			while(orientation_val != 11 && isball == false) //south
			{
				rotate(-1,30);
				wait1Msec(200);
			}
		}
		halt();
	}
}

void maneuver() //LIST ALL SCENARIOS, INCLUDE BUMPERS ETC, include scenario when opponent detected
{
	if(isballin == false) //explorer mode
	{
		//if(isopponent == true)
		//{
		//	move(-1, 30);
		//	wait1Msec(1500); //tune
		//	align();
		//}
		if(isFrontLeftclear == false)
		{
			state = "maneuvering";
			move(-1, 30);
			wait1Msec(1000);
			clearTimer(T3);
			while(orientation_val != 3 && time1(T3) < 750 && isball == false) //southwest/facing right
			{
				rotate(1, 45);
			}
			halt();
		}
		else if(isFrontRightclear == false)
		{
			state = "maneuvering";
			move(-1, 30);
			wait1Msec(1000);
			clearTimer(T3);
			while(orientation_val != 9 && time1(T3) < 750 && isball == false) //southeast/facing left
			{
				rotate(-1, 45);
			}
			halt();
		}


		//if(SensorValue(northpin) == 1 && isscanning == false) //if robot facing north/northeast/northwest -> facing collection area
		//{
		//	align();
		//}

	}
	else if(isballin == true && iscollectionarea == false) //
	{
		//if(isopponent == true)
		//{
		//	move(1, 30);
		//	wait1Msec(2000);
		//  align();
		//}
		if(isBackLeftclear == false)
		{
			rotate(-1, 80);
			wait1Msec(1000);
			move(1, 80);
			wait1Msec(1000);
			align();
		}
		else if(isBackRightclear == false)
		{
			rotate(1, 80);
			wait1Msec(1000);
			move(1, 80);
			wait1Msec(1000);
			align();
		}
	}
}

void scan() //rotate robot to scan
{
	isscanning = true;
	state = "scanning";
	clearTimer(T2);
	while(time1[T2] < 750 && isball == false) //rotate left
	{
		rotate(-1,30);
		maneuver();
	}

	clearTimer(T2);
	while(time1[T2] < 1500 && isball == false) //rotate right
	{
		rotate(1,30);
		maneuver();
	}

	clearTimer(T2);
	while(time1[T2] < 1000 && isball == false) //rotate left-> robot is back to facing north supposedly, fine tune timer
	{
		rotate(-1,30);
		maneuver();
	}

	isscanning = false;
	halt();
}

void grabball() //ball catching mechanism
{

	//motor(grabber) = 127;
	//wait1Msec(2000);
	//motor(grabber) = 0;
	//for(int count = 0; count <= 30; count++) //swing down, change to 127
	//{
	//	setServo(grabber, count);
	//	wait1Msec(1);
	//}

	for(int count = -40; count <= 105; count++) //swing down, FINE TUNE FOR THE SERVO POSITION
	{
		setServo(grabber, count);
		wait1Msec(1);
	}

	wait1Msec(2000);
}

void releaseball()
{
	//motor(grabber) = -127;
	//wait1Msec(200);
	//motor(grabber) = 0;
	for(int count = 105; count >= -40; count--) //swing up, FINE TUNE FOR THE SERVO POSITION
	{
		setServo(grabber, count);
		wait1Msec(6);
	}

	wait1Msec(3000); //wait 3s for ball to roll down


	//for(int count = -100; count <= 0; count++) //swing back to original position, FINE TUNE FOR THE SERVO POSITION
	//{
	//	setServo(grabber, count);
	//	wait1Msec(10);
	//}

}

void initialize() //initialize all values
{
	isball = false;
	isopponent = false;
	isballin = false;
	iscollectionarea = false;
	isFrontLeftclear = true;
	isFrontRightclear = true;
	isBackLeftclear = true;
	isBackRightclear = true;
	setServo(grabber, -40);
}
//end of functions

//start of side tasks
task detect_ball_opponent()
{
	while(true)
	{
		lowervalue = SensorValue(lowersensor);

		if(isballin == false)
		{
			if((SensorValue(lowersensor) > 500 && SensorValue(lowersensor) < 2500) || (SensorValue(shortsensor) < 2500 && SensorValue(shortsensor) > 1300))
			{
				if(SensorValue(uppersensor) > 1000) //uppersensor detects something, tune
				{
					//if(SensorValue(lowersensor) >= SensorValue(uppersensor) + 700) //TUNE THE 250 -> TO DIFFERENTIATE BALL/OPPONENT
					//{
					//	isball = true;
					//	isopponent = true;
					//}
					//else
					//{
					//	isball = false;
					//	isopponent = true;
					//}
					isball = false; //WHAT IF IT DETECTS COLLECTION PLACE? -> MAKE SURE ROBOT ALWAYS FAR FROM COLLECTION/ FACING FORWARD?
					isopponent = true;
				}
				else
				{
					isball = true; //WHAT IF IT DETECTS COLLECTION PLACE? -> MAKE SURE ROBOT ALWAYS FAR FROM COLLECTION/ FACING FORWARD?
					isopponent = false;
				}
			}
			else
			{
				isball = false;
				isopponent = false;
			}
		}
		else if(isballin == true && iscollectionarea == false) //returning to collection
		{
			if(SensorValue(bumperBR) == 1 && SensorValue(bumperBL) == 1 && SensorValue(rearsensor) < 500) //rear sensor doesn't detect anything
				iscollectionarea = true;
			else if(SensorValue(rearsensor) < 2500 && SensorValue(rearsensor) > 500) //PLACE REAR SENSOR HIGHER THAN COLLECTION AREA
				isopponent = true;
		}
	}
}

task detect()
{

	while(true)
	{
		//start of boundary detection
		FLval1 = SensorValue(color_FrontLeft);
		FRval1 = SensorValue(color_FrontRight);
		BLval1 = SensorValue(color_BackLeft);
		BRval1 = SensorValue(color_BackRight);

		wait1Msec(50); //tune

		FLval2 = SensorValue(color_FrontLeft);
		FRval2 = SensorValue(color_FrontRight);
		BLval2 = SensorValue(color_BackLeft);
		BRval2 = SensorValue(color_BackRight);


		if(FLval1 - FLval2  > 25) //tune
			isFrontLeftclear = false;
		else
			isFrontLeftclear = true;

		if(FRval1 - FRval2 > 25) //tune
			isFrontRightclear = false;
		else
			isFrontRightclear = true;

		if(BLval1 - BLval2 > 25) //tune
			isBackLeftclear = false;
		else
			isBackLeftclear = true;

		if(BRval1 - BRval2 > 25) //tune
			isBackRightclear = false;
		else
			isBackRightclear = true;
		//end of boundary detection

		read_compass();
	}
}
//end of side tasks


task main()
{

	startTask(detect);
	startTask(detect_ball_opponent);
	setServo(grabber, -40);
	//while(true)
	//{
	//	halt();
	//}


	while(SensorValue(uppersensor) < 1500)
	{
	}
	wait1Msec(3000);


	while(true)
	{
		initialize();

		while(isball == false) //move and search until ball detected
		{
			clearTimer(T1);
			while(time1[T1] < 2000 && isball == false) //move 2s or until ball is detected
			{
				state = "moving forward";
				maneuver(); //only if boundary is detected, see function
				move(1, 45); //move forward
			}

			halt();

			if(isball == false) //if after moving halfway still doesn't detect the ball
				scan(); //rotate to scan
		}

		while(isball == true && isballin == false) //approach ball
		{
			while(isball == true && SensorValue(lowersensor) < 2400) //approach until ball is within range (FINE TUNE)
			{
				state = "approaching ball";
				move(1,30); //if suddenly ball gone, it will stop moving
				wait1Msec(200); //tune
				maneuver(); //do we need to care abt boundary when chasing ball? what if ball is at the corner?
			}

			halt();

			if(isball == true) //SensorValue(lowersensor) > 2450) -> to check whether ball is within capturing range FINE TUNE if ball suddenly gone, skip this function
			{
				state = "catching ball";
				grabball();
				isballin = true; //ONLY FOR TESTING
			}
			else
			{
				scan();
			}
			//in case ball gone while approaching, the code will loop from beginning (search ball)

			//if(/*SensorValue(shortsensor) > 1200*/ SensorValue(lowersensor) < 2500) //FINE TUNE, if after grabball is done, ball is in
			//{
			//	isballin = true;
			//}
			//else //rotate until find ball, ball should be nearby (logically)
			//{
			//	isballin = false;
			//	scan();
			//}
		}

		while(isballin == true /*&& iscollectionarea == false*/) //if ball is grabbed, return to collection, MAKE SURE CANNOT LOSE HOLD OF BALL
		{
			align();

			//FOR INITIAL TESTING ONLY
			clearTimer(T3);
			while(time1[T3] < 3000) //move until halfway or until ball is detected
			{
				state = "returning home";
				maneuver(); //only if boundary is detected, see function
				move(-1, 45); //move backward
			}
			halt();

			//while(iscollectionarea == false) //need to add codes to task "detection" to check for collection area
			//{
			//	maneuver(); //make sure to edit the function
			//	move(-1, 90); //move backwards
			//}

			releaseball(); //release ball to collection
			break;
			//after releasing, loop back to top
		}
	}
}
